"""Code Generation Create Tool for AINative API.

This module provides a wrapper for the AINative code-generation/create endpoint
that generates new code based on provided specifications.
"""

import logging
from typing import Any, Dict, List, Optional

from .base import AINativeBaseTool

# Configure logging
logger = logging.getLogger(__name__)


class CodeGenCreateTool(AINativeBaseTool):
    """Wrapper for the AI code generation endpoint.
    
    This class provides methods to generate new code based on
    project specifications and requirements using the Cody AI Development Platform.
    """
    
    def __init__(self) -> None:
        """Initialize the CodeGenCreateTool with the appropriate endpoint."""
        super().__init__(endpoint="ai/analyze")
    
    async def _call(
        self,
        project_name: str,
        description: str,
        features: List[str],
        tech_stack: str,
        styling: Optional[str] = None,
        canvas_layout: Optional[List[Dict[str, Any]]] = None,
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Generate new code based on project specifications.
        
        Args:
            project_name: Name of the project.
            description: Description of the project.
            features: List of features to implement.
            tech_stack: Technology stack to use.
            styling: Optional frontend styling framework.
            canvas_layout: Optional canvas layout for UI components.
            **kwargs: Additional parameters to pass to the API.
            
        Returns:
            Dictionary containing generated code or error information.
        """
        payload = {
            "project_name": project_name,
            "description": description,
            "features": features,
            "tech_stack": tech_stack,
            "generate_code": True,
            **kwargs
        }
        
        # Add optional parameters only if they have values
        if styling:
            payload["styling"] = styling
            
        if canvas_layout:
            payload["canvas_layout"] = canvas_layout
        
        logger.info(f"Creating code generation for project: {project_name}")
        logger.debug(f"CodeGenCreateTool payload: {payload}")
        
        api_response = await self._make_request(payload)
        
        # Process the real API response into the format expected by the execution loop
        if not self.mock_mode and "data" in api_response:
            logger.info("Processing real API response")
            
            # Determine file path and code based on tech stack
            file_path = "README.md"
            if "python" in tech_stack.lower():
                file_path = "main.py"
            elif "javascript" in tech_stack.lower() or "react" in tech_stack.lower():
                file_path = "app.js"
                
            # Generate a basic README.md with project details and real API analysis
            code = f"""# {project_name}

## Description
{description}

## Features
{chr(10).join(['- ' + feature for feature in features])}

## Tech Stack
{tech_stack}

## Analysis
- Quality Score: {api_response.get('data', {}).get('quality_score', 'N/A')}
- Complexity: {api_response.get('data', {}).get('complexity', 'N/A')}

## Generated by Cody AI Development Platform
"""
            
            # Transform the API response into the expected format
            transformed_response = {
                "success": api_response.get("success", True),
                "mock": False,
                "message": f"Successfully generated code for {project_name}",
                "file_path": file_path,
                "code": code,
                "analysis": api_response.get("data", {}),
                "raw_api_response": api_response
            }
            
            return transformed_response
        
        return api_response
    
    def _generate_mock_response(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Generate a realistic mock response for testing purposes.
        
        Args:
            payload: The request payload that would have been sent to the API.
            
        Returns:
            Dictionary containing a mock response with generated code.
        """
        project_name = payload.get("project_name", "Unknown Project")
        tech_stack = payload.get("tech_stack", "Python")
        
        # Create a mock file structure based on tech stack
        if "python" in tech_stack.lower():
            file_path = "main.py"
            code = f"""# {project_name}
# Generated by Cody AI Development Platform (Mock)

import os
import sys
from typing import List, Dict, Any

def main():
    print("Welcome to {project_name}!")
    print("This is a mock generated application")
    # TODO: Implement application logic
    features = {payload.get('features', ['Default feature'])}
    for i, feature in enumerate(features, 1):
        print(f"Feature {{i}}: {{feature}}")

if __name__ == "__main__":
    main()
"""
        elif "javascript" in tech_stack.lower() or "react" in tech_stack.lower():
            file_path = "app.js"
            code = f"""// {project_name}
// Generated by Cody AI Development Platform (Mock)

import React from 'react';
import ReactDOM from 'react-dom';

function App() {{
  const features = {payload.get('features', ['Default feature'])};
  
  return (
    <div className="App">
      <header className="App-header">
        <h1>{project_name}</h1>
        <p>This is a mock generated application</p>
        <ul>
          {{features.map((feature, index) => (
            <li key={{index}}>{{feature}}</li>
          ))}}
        </ul>
      </header>
    </div>
  );
}}

ReactDOM.render(<App />, document.getElementById('root'));
"""
        else:
            file_path = "README.md"
            code = f"""# {project_name}

## Description
{payload.get('description', 'No description provided')}

## Features
{chr(10).join(['- ' + feature for feature in payload.get('features', ['Default feature'])])}

## Tech Stack
{tech_stack}

## Generated by Cody AI Development Platform (Mock)
"""
        
        return {
            "success": True,
            "mock": True,
            "message": f"Successfully generated code for {project_name}",
            "file_path": file_path,
            "code": code,
            "analysis": {
                "complexity": "medium",
                "estimated_development_time": "2-3 days",
                "recommended_structure": ["src/", "tests/", "docs/"],
                "tech_stack_compatibility": "high"
            },
            "received_payload": payload
        }
